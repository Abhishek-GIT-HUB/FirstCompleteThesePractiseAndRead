# FirstCompleteThesePractiseAndRead

Tupple <br />
Generic list <br />
Generic interface <br />
extension generic method <br/>
Async await <br />
Code it by Ambition ( reflection, process manipulation) <br />
Null handling techniques <br />
Covariance contravarience <br />
RECORds <br />
Monad <br />
Pattern matching <br />


TDD <br />
unit testing <br />
integration testing <br />
functional testing <br />
Load testing <br />
write unit test case for cancellation token<br />
write unit test case for polly <br />
write unit test case for retry limit<br />


Architecture testing(Narch unit) <br />

Aggregarate root design <br />
Strongly type properties <br />
Value object <br />
Entity to db mapping <br />
Domain validation <br />
Domain modelin <br />
ANEMIC model <br />


Complex Linqu <br />
Expression <br />
Funct as parameter <br />
---EF <br />
Tda ef core ( searh on ai & create project with this approach every time)<br />
Aggregarate root design <br />

Specification pattern <br />
Keep master data with migration <br />


  Pattern <br />
Behaviour pattern <br />
Adapter pattern <br />
Decorator <br />
Builder <br />
 
  principles <br />
Tell dont ask ( e.g. ef core entity crud or validation)<br />
Fail fast <br />
Dependency inversion principle <br />


C# api result expression with gaurd ( search in AI and implemnent) <br />
CQRS mediate + create own cqrs <br />
Cqrs event <br />
Public Api authentication <br />
User auenticattion .net core <br />
Tokens and authentication <br />
Rate limilit <br />
Middleware configurations( Dependency injection) <br />
Application exception handling <br />
Global error handling <br />
Specification pattern <br />
Caching reddis / distributed / flush <br />
Message broker / kafka / service bus <br /> 
Shared kernel ( working with ardalis) <br />
Tracing / serilog / app log <br />
Api versioning  <br />
Polly / Fault tolerance <br />
 Open telemetary <br />
Api documentation ( swagger/Open Api) <br />
Gaurd clause <br/>
Idempotent Api <br />
result pattern 
